import "./chunk-RSJERJUL.js";

// node_modules/motion-sensors-polyfill/sensor.js
var __sensor__ = Symbol("__sensor__");
var slot = __sensor__;
function defineProperties(target, descriptions) {
  for (const property in descriptions) {
    Object.defineProperty(target, property, {
      configurable: true,
      value: descriptions[property]
    });
  }
}
var EventTargetMixin = (superclass, ...eventNames) => class extends superclass {
  constructor(...args) {
    super(args);
    const eventTarget = document.createDocumentFragment();
    this.addEventListener = (type, ...args2) => {
      return eventTarget.addEventListener(type, ...args2);
    };
    this.removeEventListener = (...args2) => {
      return eventTarget.removeEventListener(...args2);
    };
    this.dispatchEvent = (event) => {
      defineProperties(event, { currentTarget: this });
      if (!event.target) {
        defineProperties(event, { target: this });
      }
      const methodName = `on${event.type}`;
      if (typeof this[methodName] == "function") {
        this[methodName](event);
      }
      const retValue = eventTarget.dispatchEvent(event);
      if (retValue && this.parentNode) {
        this.parentNode.dispatchEvent(event);
      }
      defineProperties(event, { currentTarget: null, target: null });
      return retValue;
    };
  }
};
var EventTarget = class extends EventTargetMixin(Object) {
};
function defineReadonlyProperties(target, slot3, descriptions) {
  const propertyBag = target[slot3];
  for (const property in descriptions) {
    propertyBag[property] = descriptions[property];
    Object.defineProperty(target, property, {
      get: () => propertyBag[property]
    });
  }
}
var SensorErrorEvent = class extends Event {
  constructor(type, errorEventInitDict) {
    super(type, errorEventInitDict);
    if (!errorEventInitDict || !(errorEventInitDict.error instanceof DOMException)) {
      throw TypeError(
        "Failed to construct 'SensorErrorEvent':2nd argument much contain 'error' property"
      );
    }
    Object.defineProperty(this, "error", {
      configurable: false,
      writable: false,
      value: errorEventInitDict.error
    });
  }
};
function defineOnEventListener(target, name) {
  Object.defineProperty(target, `on${name}`, {
    enumerable: true,
    configurable: false,
    writable: true,
    value: null
  });
}
var SensorState = {
  IDLE: 1,
  ACTIVATING: 2,
  ACTIVE: 3
};
var Sensor = class extends EventTarget {
  constructor(options) {
    super();
    this[slot] = /* @__PURE__ */ new WeakMap();
    defineOnEventListener(this, "reading");
    defineOnEventListener(this, "activate");
    defineOnEventListener(this, "error");
    defineReadonlyProperties(this, slot, {
      activated: false,
      hasReading: false,
      timestamp: null
    });
    this[slot].state = SensorState.IDLE;
    this[slot].notifyError = (message, name) => {
      let error = new SensorErrorEvent("error", {
        error: new DOMException(message, name)
      });
      this.dispatchEvent(error);
      this.stop();
    };
    this[slot].notifyActivatedState = () => {
      let activate = new Event("activate");
      this[slot].activated = true;
      this.dispatchEvent(activate);
      this[slot].state = SensorState.ACTIVE;
    };
    this[slot].activateCallback = () => {
    };
    this[slot].deactivateCallback = () => {
    };
    this[slot].frequency = null;
    if (window && window.parent != window.top) {
      throw new DOMException("Only instantiable in a top-level browsing context", "SecurityError");
    }
    if (options && typeof options.frequency == "number") {
      if (options.frequency > 60) {
        this.frequency = options.frequency;
      }
    }
  }
  start() {
    if (this[slot].state === SensorState.ACTIVATING || this[slot].state === SensorState.ACTIVE) {
      return;
    }
    this[slot].state = SensorState.ACTIVATING;
    this[slot].activateCallback();
  }
  stop() {
    if (this[slot].state === SensorState.IDLE) {
      return;
    }
    this[slot].activated = false;
    this[slot].hasReading = false;
    this[slot].timestamp = null;
    this[slot].deactivateCallback();
    this[slot].state = SensorState.IDLE;
  }
};

// node_modules/motion-sensors-polyfill/motion-sensors.js
var slot2 = __sensor__;
var orientation;
if (screen.orientation) {
  orientation = screen.orientation;
} else if (screen.msOrientation) {
  orientation = screen.msOrientation;
} else {
  orientation = {};
  Object.defineProperty(orientation, "angle", {
    get: () => {
      return window.orientation || 0;
    }
  });
}
var DeviceOrientationMixin = (superclass, ...eventNames) => class extends superclass {
  constructor(...args) {
    super(args);
    for (const eventName of eventNames) {
      if (`on${eventName}` in window) {
        this[slot2].eventName = eventName;
        break;
      }
    }
    this[slot2].activateCallback = () => {
      window.addEventListener(this[slot2].eventName, this[slot2].handleEvent, { capture: true });
    };
    this[slot2].deactivateCallback = () => {
      window.removeEventListener(this[slot2].eventName, this[slot2].handleEvent, { capture: true });
    };
  }
};
function toQuaternionFromEuler(alpha, beta, gamma) {
  const degToRad = Math.PI / 180;
  const x = (beta || 0) * degToRad;
  const y = (gamma || 0) * degToRad;
  const z = (alpha || 0) * degToRad;
  const cZ = Math.cos(z * 0.5);
  const sZ = Math.sin(z * 0.5);
  const cY = Math.cos(y * 0.5);
  const sY = Math.sin(y * 0.5);
  const cX = Math.cos(x * 0.5);
  const sX = Math.sin(x * 0.5);
  const qx = sX * cY * cZ - cX * sY * sZ;
  const qy = cX * sY * cZ + sX * cY * sZ;
  const qz = cX * cY * sZ + sX * sY * cZ;
  const qw = cX * cY * cZ - sX * sY * sZ;
  return [qx, qy, qz, qw];
}
function rotateQuaternionByAxisAngle(quat, axis, angle) {
  const sHalfAngle = Math.sin(angle / 2);
  const cHalfAngle = Math.cos(angle / 2);
  const transformQuat = [
    axis[0] * sHalfAngle,
    axis[1] * sHalfAngle,
    axis[2] * sHalfAngle,
    cHalfAngle
  ];
  function multiplyQuaternion(a, b) {
    const qx = a[0] * b[3] + a[3] * b[0] + a[1] * b[2] - a[2] * b[1];
    const qy = a[1] * b[3] + a[3] * b[1] + a[2] * b[0] - a[0] * b[2];
    const qz = a[2] * b[3] + a[3] * b[2] + a[0] * b[1] - a[1] * b[0];
    const qw = a[3] * b[3] - a[0] * b[0] - a[1] * b[1] - a[2] * b[2];
    return [qx, qy, qz, qw];
  }
  function normalizeQuaternion(quat2) {
    const length = Math.sqrt(quat2[0] ** 2 + quat2[1] ** 2 + quat2[2] ** 2 + quat2[3] ** 2);
    if (length === 0) {
      return [0, 0, 0, 1];
    }
    return quat2.map((v) => v / length);
  }
  return normalizeQuaternion(multiplyQuaternion(quat, transformQuat));
}
function toMat4FromQuat(mat, q) {
  const typed = mat instanceof Float32Array || mat instanceof Float64Array;
  if (typed && mat.length >= 16) {
    mat[0] = 1 - 2 * (q[1] ** 2 + q[2] ** 2);
    mat[1] = 2 * (q[0] * q[1] - q[2] * q[3]);
    mat[2] = 2 * (q[0] * q[2] + q[1] * q[3]);
    mat[3] = 0;
    mat[4] = 2 * (q[0] * q[1] + q[2] * q[3]);
    mat[5] = 1 - 2 * (q[0] ** 2 + q[2] ** 2);
    mat[6] = 2 * (q[1] * q[2] - q[0] * q[3]);
    mat[7] = 0;
    mat[8] = 2 * (q[0] * q[2] - q[1] * q[3]);
    mat[9] = 2 * (q[1] * q[2] + q[0] * q[3]);
    mat[10] = 1 - 2 * (q[0] ** 2 + q[1] ** 2);
    mat[11] = 0;
    mat[12] = 0;
    mat[13] = 0;
    mat[14] = 0;
    mat[15] = 1;
  }
  return mat;
}
function worldToScreen(quaternion) {
  return !quaternion ? null : rotateQuaternionByAxisAngle(
    quaternion,
    [0, 0, 1],
    -orientation.angle * Math.PI / 180
  );
}
var RelativeOrientationSensor = window.RelativeOrientationSensor || class RelativeOrientationSensor2 extends DeviceOrientationMixin(Sensor, "deviceorientation") {
  constructor(options = {}) {
    super(options);
    switch (options.coordinateSystem || "world") {
      case "screen":
        Object.defineProperty(this, "quaternion", {
          get: () => worldToScreen(this[slot2].quaternion)
        });
        break;
      case "world":
      default:
        Object.defineProperty(this, "quaternion", {
          get: () => this[slot2].quaternion
        });
    }
    this[slot2].handleEvent = (event) => {
      if (event.absolute || event.alpha === null) {
        this[slot2].notifyError("Could not connect to a sensor", "NotReadableError");
        return;
      }
      if (!this[slot2].activated) {
        this[slot2].notifyActivatedState();
      }
      this[slot2].timestamp = performance.now();
      this[slot2].quaternion = toQuaternionFromEuler(
        event.alpha,
        event.beta,
        event.gamma
      );
      this[slot2].hasReading = true;
      this.dispatchEvent(new Event("reading"));
    };
    this[slot2].deactivateCallback = () => {
      this[slot2].quaternion = null;
    };
  }
  populateMatrix(mat) {
    toMat4FromQuat(mat, this.quaternion);
  }
};
var AbsoluteOrientationSensor = window.AbsoluteOrientationSensor || class AbsoluteOrientationSensor2 extends DeviceOrientationMixin(
  Sensor,
  "deviceorientationabsolute",
  "deviceorientation"
) {
  constructor(options = {}) {
    super(options);
    switch (options.coordinateSystem || "world") {
      case "screen":
        Object.defineProperty(this, "quaternion", {
          get: () => worldToScreen(this[slot2].quaternion)
        });
        break;
      case "world":
      default:
        Object.defineProperty(this, "quaternion", {
          get: () => this[slot2].quaternion
        });
    }
    this[slot2].handleEvent = (event) => {
      const isAbsolute = event.absolute === true || "webkitCompassHeading" in event;
      const hasValue = event.alpha !== null || event.webkitCompassHeading !== void 0;
      if (!isAbsolute || !hasValue) {
        this[slot2].notifyError("Could not connect to a sensor", "NotReadableError");
        return;
      }
      if (!this[slot2].activated) {
        this[slot2].notifyActivatedState();
      }
      this[slot2].hasReading = true;
      this[slot2].timestamp = performance.now();
      const heading = event.webkitCompassHeading != null ? 360 - event.webkitCompassHeading : event.alpha;
      this[slot2].quaternion = toQuaternionFromEuler(
        heading,
        event.beta,
        event.gamma
      );
      this.dispatchEvent(new Event("reading"));
    };
    this[slot2].deactivateCallback = () => {
      this[slot2].quaternion = null;
    };
  }
  populateMatrix(mat) {
    toMat4FromQuat(mat, this.quaternion);
  }
};
var Gyroscope = window.Gyroscope || class Gyroscope2 extends DeviceOrientationMixin(Sensor, "devicemotion") {
  constructor(options) {
    super(options);
    this[slot2].handleEvent = (event) => {
      if (event.rotationRate.alpha === null) {
        this[slot2].notifyError("Could not connect to a sensor", "NotReadableError");
        return;
      }
      if (!this[slot2].activated) {
        this[slot2].notifyActivatedState();
      }
      this[slot2].timestamp = performance.now();
      this[slot2].x = event.rotationRate.alpha;
      this[slot2].y = event.rotationRate.beta;
      this[slot2].z = event.rotationRate.gamma;
      this[slot2].hasReading = true;
      this.dispatchEvent(new Event("reading"));
    };
    defineReadonlyProperties(this, slot2, {
      x: null,
      y: null,
      z: null
    });
    this[slot2].deactivateCallback = () => {
      this[slot2].x = null;
      this[slot2].y = null;
      this[slot2].z = null;
    };
  }
};
var Accelerometer = window.Accelerometer || class Accelerometer2 extends DeviceOrientationMixin(Sensor, "devicemotion") {
  constructor(options) {
    super(options);
    this[slot2].handleEvent = (event) => {
      if (event.accelerationIncludingGravity.x === null) {
        this[slot2].notifyError("Could not connect to a sensor", "NotReadableError");
        return;
      }
      if (!this[slot2].activated) {
        this[slot2].notifyActivatedState();
      }
      this[slot2].timestamp = performance.now();
      this[slot2].x = event.accelerationIncludingGravity.x;
      this[slot2].y = event.accelerationIncludingGravity.y;
      this[slot2].z = event.accelerationIncludingGravity.z;
      this[slot2].hasReading = true;
      this.dispatchEvent(new Event("reading"));
    };
    defineReadonlyProperties(this, slot2, {
      x: null,
      y: null,
      z: null
    });
    this[slot2].deactivateCallback = () => {
      this[slot2].x = null;
      this[slot2].y = null;
      this[slot2].z = null;
    };
  }
};
var LinearAccelerationSensor = window.LinearAccelerationSensor || class LinearAccelerationSensor2 extends DeviceOrientationMixin(Sensor, "devicemotion") {
  constructor(options) {
    super(options);
    this[slot2].handleEvent = (event) => {
      if (event.acceleration.x === null) {
        this[slot2].notifyError("Could not connect to a sensor", "NotReadableError");
        return;
      }
      if (!this[slot2].activated) {
        this[slot2].notifyActivatedState();
      }
      this[slot2].timestamp = performance.now();
      this[slot2].x = event.acceleration.x;
      this[slot2].y = event.acceleration.y;
      this[slot2].z = event.acceleration.z;
      this[slot2].hasReading = true;
      this.dispatchEvent(new Event("reading"));
    };
    defineReadonlyProperties(this, slot2, {
      x: null,
      y: null,
      z: null
    });
    this[slot2].deactivateCallback = () => {
      this[slot2].x = null;
      this[slot2].y = null;
      this[slot2].z = null;
    };
  }
};
var GravitySensor = window.GravitySensor || class GravitySensor2 extends DeviceOrientationMixin(Sensor, "devicemotion") {
  constructor(options) {
    super(options);
    this[slot2].handleEvent = (event) => {
      if (event.acceleration.x === null || event.accelerationIncludingGravity.x === null) {
        this[slot2].notifyError("Could not connect to a sensor", "NotReadableError");
        return;
      }
      if (!this[slot2].activated) {
        this[slot2].notifyActivatedState();
      }
      this[slot2].timestamp = performance.now();
      this[slot2].x = event.accelerationIncludingGravity.x - event.acceleration.x;
      this[slot2].y = event.accelerationIncludingGravity.y - event.acceleration.y;
      this[slot2].z = event.accelerationIncludingGravity.z - event.acceleration.z;
      this[slot2].hasReading = true;
      this.dispatchEvent(new Event("reading"));
    };
    defineReadonlyProperties(this, slot2, {
      x: null,
      y: null,
      z: null
    });
    this[slot2].deactivateCallback = () => {
      this[slot2].x = null;
      this[slot2].y = null;
      this[slot2].z = null;
    };
  }
};
export {
  AbsoluteOrientationSensor,
  Accelerometer,
  GravitySensor,
  Gyroscope,
  LinearAccelerationSensor,
  RelativeOrientationSensor
};
//# sourceMappingURL=motion-sensors-polyfill.js.map
